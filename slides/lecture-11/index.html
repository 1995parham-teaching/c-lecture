---
index: 11
title: Structures
topics:
- Introduction
- Struct Definition
- Using Struct
- Linked List
- Enum Definition
- Union Definition
---

<section>
  <div class="toc"></div>
</section>
<section>
  <div class="toc" data-selected="0"></div>
</section>
<section>
  <section>
    <h2>Introduction</h2>
    <ul>
      <li>Our variables until now</li>
      <ul>
        <li>Single variable</li>
        <pre><code class="hljs lang-c">
int i, char c, float f
        </code></pre>
        <li>Set of <span class="orange-select">same type</span> elements: Array</li>
        <pre><code class="hljs lang-c">
int a[10], char c[20]
        </code></pre>
      </ul>
    </ul>
  </section>
  <section>
    <ul>
      <li>If data are not same type, but related? Example: Information about students:</li>
      <ul>
        <li>Student Name</li>
        <li>Student Family Name</li>
        <li>Student Number</li>
        <li>Student Grade</li>
      </ul>
    </ul>
  </section>
</section>
<section>
  <h2>Introduction</h2>
  <ul>
    <li>How to save the student information?</li>
    <li>1- Use separated variables</li>
    <pre><code class="hljs lang-c">
char st_name[20];
char st_fam_name[20];
int id;
int grade;
    </code></pre>
    <li>2- Put them altogether, they are related</li>
    <ul>
      <li>Use <span class="cyan-select">struct</span></li>
      <li>This concept is extended in OOP as the <span class="green-select">object</span></li>
    </ul>
  </ul>
</section>
<section>
  <div class="toc" data-selected="1"></div>
</section>
<section>
  <h2>struct: version 1</h2>
  <ul>
    <li>Set of related variables</li>
    <ul>
      <li>Each variable in <span class="cyan-select">struct</span> has its <span class="orange-select">own type</span></li>
      <li><span class="cyan-select">struct</span> in C (version 1)</li>
      <p>
        <span class="cyan-select">struct</span> {<br>
        &nbsp;<span class="violet-select">&lt;variable declaration&gt;</span><br>
        } <span class="green-select">&lt;identifier list&gt;</span>;<br>
      </p>
    </ul>
  </ul>
</section>
<section>
  <h2>struct (version 1): Example</h2>
  <pre><code class="hljs lang-c">
struct{
  char st_name[20];
  char st_fam_name[20];
  int id;
  int grade;
} st1;
  </code></pre>
  <ul>
    <li>We declare a variable <span class="orange-select">st1</span></li>
    <li>Type of <span class="orange-select">st1</span> is struct</li>
    <li><span class="violet-select">id</span> is a <span class="green-select">member</span> of the struct</li>
    <li><span class="violet-select">grade</span> is a <span class="green-select">member</span> of the struct</li>
  </ul>
</section>
<section>
  <h2>struct (version 1): Example</h2>
  <pre><code class="hljs lang-c">
struct{
  char st_name[20];
  char st_fam_name[20];
  int id;
  int grade;
} st1, st2, st3;
  </code></pre>
  <ul>
    <li>We declare three variables: <span class="orange-select">st1</span>, <span class="orange-select">st2</span>, <span class="orange-select">st3</span></li>
    <li>Type of <span class="orange-select">st1</span>, <span class="orange-select">st2</span>, <span class="orange-select">st3</span> is the struct</li>
    <li>In this model, we cannot reuse the struct definition in other location (e.g., input of function)</li>
  </ul>
</section>
<section>
  <h2>struct: Version 2</h2>
  <ul>
    <li><span class="cyan-select">struct</span> in C (version 2)</li>
    <p>
      <span class="cyan-select">struct</span> <span class="yellow-select">&lt;tag&gt;</span> {<br>
      &nbsp;<span class="violet-select">&lt;variable declaration&gt;</span><br>
      };<br>
      <span class="cyan-select">struct</span> <span class="yellow-select">&lt;tag&gt;</span> <span class="green-select">&lt;identifier list&gt;</span>;<br>
    </p>
  </ul>
</section>
<section>
  <h2>struct (version 2): Example</h2>
  <pre><code class="hljs lang-c">
struct std_info {
  char st_name[20];
  char st_fam_name[20];
  int id;
  int grade;
};
struct std_info st1, st2, st3;
  </code></pre>
  <ul>
    <li>We define a struct with tag <span class="orange-select">std_info</span></li>
    <ul>
      <li>We don’t allocate memory, it is just definition</li>
    </ul>
    <li>We declare variables <span class="green-select">st1</span>, <span class="green-select">st2</span>, <span class="green-select">st3</span> from <span class="orange-select">std_info</span></li>
  </ul>
</section>
<section>
  <h2>typedef</h2>
  <ul>
    <li>We can assign a new name for each type</li>
    <ul>
      <li>Assign name <span class="green-select">“integer”</span> to <span class="orange-select">“int”</span></li>
      <li>Assign name <span class="green-select">“int_array”</span> to <span class="orange-select">“int[100]”</span></li>
      <li>Assign name <span class="green-select">“int_pointer”</span> to <span class="orange-select">“int *”</span></li>
    </ul>
    <li>New names are assigned by <span class="violet-select">typedef</span></li>
    <li>After we assigned the new name, we can use it in identifier declaration</li>
  </ul>
</section>
<section>
  <h2>typedef: Examples</h2>
  <pre><code class="hljs lang-c">
/* Assign new name integer to type int */
typedef int integer;

/* Use the new name */
integer i, j, k;

/* Assign new name alephba to type char */
typedef char alephba;

/* Use the new name */
alephba c1, c2;
  </code></pre>
</section>
<section>
  <h2>typedef: Examples</h2>
  <pre><code class="hljs lang-c">
/* Assign new name intptr to type int * */
typedef int * intptr;

/* Use the new name */
intptr pi, pj, pk;

typedef int int_arr1[10], int_arr2[20];

int_arr1 array1;
int_arr2 array2;
  </code></pre>
</section>
<section>
  <h2>typedef: Cons</h2>
  <pre><code class="hljs lang-c">
typedef int arr[100];

int main() {
  arr a1;
  arr a2;

  a1 = a2; // error: array type 'arr' (aka 'int [100]') is not assignable
}
  </code></pre>
</section>
<section>
  <h2>struct: Version 3.1</h2>
  <ul>
    <li><span class="cyan-select">struct</span> in C (version 3.1)</li>
    <li>Using the <span class="orange-select">typedef</span></li>
    <p>
      <span class="cyan-select">struct</span> <span class="yellow-select">&lt;tag&gt;</span> {<br>
      &nbsp;<span class="violet-select">&lt;variable declaration&gt;</span><br>
      };<br>
      <span class="orange-select">typedef</span> <span class="cyan-select">struct</span> <span class="yellow-select">&lt;tag&gt;</span>
      <span class="red-select">&lt;new_name&gt;</span>;<br>
      <span class="red-select">&lt;new_name&gt;</span> <span class="green-select">&lt;identifier list&gt;</span>;<br>
    </p>
  </ul>
</section>
<section>
  <h2>struct (Version 3.1): Examples</h2>
  <pre><code class="hljs lang-c">
struct std_info{
  char st_name[20];
  char st_fam_name[20];
  int id;
  int grade;
};

typedef struct std_info information;

information st1, st2;
  </code></pre>
</section>
<section>
  <h2>struct: Version 3.2</h2>
  <ul>
    <li><span class="cyan-select">struct</span> in C (version 3.2)</li>
    <li>Using the <span class="orange-select">typedef</span></li>
    <p>
      <span class="orange-select">typedef</span> <span class="cyan-select">struct</span> {<br>
      &nbsp;<span class="violet-select">&lt;variable declaration&gt;</span><br>
      } <span class="red-select">&lt;new_name&gt;</span>;<br>
      <span class="red-select">&lt;new_name&gt;</span> <span class="green-select">&lt;identifier list&gt;</span>;<br>
    </p>
  </ul>
</section>
<section>
  <h2>struct (Version 3.2): Examples</h2>
  <pre><code class="hljs lang-c">
typedef struct {
  char st_name[20];
  char st_fam_name[20];
  int id;
  int grade;
} information;
information st1, st2;
  </code></pre>
</section>
<section>
  <h2>Structures as New Data Type</h2>
  <ul>
    <li>When we define a new struct, in fact we are defining a new data type</li>
    <ul>
      <li>Then we use the new data type and define variables</li>
    </ul>
    <li>So, we need to learn how to work it</li>
    <ul>
      <li>Access to members</li>
      <li>Operators for struct</li>
      <li>Array of struct</li>
      <li>struct in functions</li>
      <li>Pointer to struct</li>
    </ul>
  </ul>
</section>
<section>
  <h2>Size of struct</h2>
  <ul>
    <li>The size of struct is <span class="red-select">NOT</span> the sum of size of members</li>
    <ul>
      <li><pre><code class="hljs lang-c">struct test_size{char c, int i}</code></pre></li>
      <li><pre><code class="hljs lang-c">sizeof(struct test_size) = 8</code></pre></li>
    </ul>
    <li>This is because of <span class="orange-select">Structure Padding</span></li>
    <ul>
      <li>Computer HW cannot (should not) read any arbitrary address</li>
      <li>The address should be aligned in word</li>
      <ul>
        <li>4 bytes in 32-bit machine</li>
      </ul>
      <li>The padding is to align the address</li>
      <li>More details &amp; examples: <a href="https://fresh2refresh.com/c-programming/c-structure-padding">Here</a></li>
    </ul>
  </ul>
</section>
<section>
  <div class="toc" data-selected="2"></div>
</section>
<section>
  <h2>Using struct</h2>
  <ul>
    <li>We should declare variables from struct type</li>
    <ul>
      <li>Versions 1, 2, 3.1, 3.2</li>
    </ul>
    <li>How to access to the members of struct</li>
    <ul>
      <li><span class="orange-select">&lt;struct variable&gt;</span>.<span class="green-select">&lt;element name&gt;</span></li>
      <li><span class="cyan-select">st1.st_name</span> is a array of char in struct st1</li>
      <li><span class="cyan-select">st2.grade</span> is a int variable in struct st2</li>
    </ul>
  </ul>
</section>
<section>
  <ul>
    <li>Similar to array initialization</li>
    <pre><code class="hljs lang-c">
struct std_info st1 = {"Parham", "Alvani", 9231058, 18};
    </code></pre>
    <li><span class="orange-select">“Parham”</span> is assigned to <span class="green-select">st_name</span></li>
    <li><span class="orange-select">“Alvani”</span> is assigned to <span class="green-select">st_fam_name</span></li>
    <li><span class="orange-select">9231058</span> is assigned to <span class="green-select">id</span></li>
    <li><span class="orange-select">18</span> is assigned to <span class="green-select">grade</span></li>
    <li class="cyan-select">Order of values should be exactly the order of the members</li>
    <li class="violet-select">The number of values should be &lt;= the number of members</li>
    <li class="red-select">Initial values cannot be assigned in struct definition</li>
  </ul>
</section>
<section>
  <h2>Example</h2>
  <pre><code class="hljs lang-c">
#include &lt;stdio.h&gt;

typedef struct {
  char name[20];
  char fam_name[20];
  int id;
  int grade;
} information;

void main(void){
  information st2, st1 = {"Parham", "Alvani", 9231058, 20};

  printf("After init: \n");
  printf("Name = %s, \nFam. Name = %s, \nid = %d, \ngrade = %d\n", st1.name, st1.fam_name, st1.id, st1.grade);

  scanf("%s", st2.name);
  scanf("%s", st2.fam_name);
  scanf("%d", &amp;st2.id);
  scanf("%d", &amp;st2.grade);

  printf("Your Input is: \n");
  printf("Name = %s, \nFam. Name = %s, \nid = %d, \ngrade = %d\n", st2.name, st2.fam_name, st2.id, st2.grade);
}
  </code></pre>
</section>
<section>
  <h2>Nested struct</h2>
  <pre><code class="hljs lang-c">
struct date_type{
  int day, month, year;
};

typedef struct{
  char name[20];
  char fam_name[20];
  int id;
  int grade;
  struct date_type date;
} information;
  </code></pre>
</section>
<section>
  <section>
    <h2>Nested struct</h2>
    <pre><code class="hljs lang-c">
information st1 = {"A", "B", 1, 10, {2, 3, 1368}};
    </code></pre>
    <pre><code class="hljs lang-c">
information st2;
// st2.name = "C"; char[20] is not assignable
// st2.fam_name = "D"; char[20] is not assignable
st2.id = 2;
st2.grade = 15;
    </code></pre>
    <pre><code class="hljs lang-c">
st2.date.day = 10;
st2.date.month = 5;
st2.date.year = 1390;
    </code></pre>
  </section>
  <section>
    <h2>More on "char[20] is not assignable"</h2>
    <pre><code class="hljs lang-c">
struct person {
  char name[200];
  char family[200];
};
    </code></pre>
    <pre><code class="hljs lang-c">
char hello[200] = "Hello world";
printf("%s\n", hello);

hello[0] = 'h';
printf("%s\n", hello);

// hello = "123";

struct person p1 = {"Parham", "Alvani"};
printf("%s\n", p1.name);

p1.name[0] = 'p';
printf("%s\n", p1.name);

// p1.name = "123";
    </code></pre>
  </section>
</section>
<section>
  <h2>struct: Copy and Assignment</h2>
  <pre><code class="hljs lang-c">
struct date_type{
  int day, month, year;
};

struct date_type d1, d2 = {2, 1, 1360};
d1 = d2;

/*
  d1.day = d2.day;
  d1.month = d2.month;
  d1.year = d2.year;
*/
  </code></pre>
</section>
<section>
  <h2>struct: Copy and Assignment 😮</h2>
  <pre><code class="hljs lang-c">
struct test_type{
  char name[10];
  int id[10];
};

struct test_type d1, d2 = {"ABC", {1, 2, 3}};
d1 = d2;
/*
 d1.name = "ABC";
 d1.id = {1, 2, 3};
*/

  </code></pre>
</section>
<section>
  <h2>struct: Comparing</h2>
  <ul>
    <li>We <span class="orange-select">cannot</span> compare <span class="cyan-select">struct</span> variables</li>
    <ul>
      <li>==, &lt;=, &lt;, &gt;, &gt;= cannot be used for struct</li>
    </ul>
    <pre><code class="hljs lang-c">
information st1, st2;

if(st1 &lt;= st2){
  // Compile Error ...
}

    </code></pre>
    <li>Why?</li>
    <ul>
      <li>What does this mean? st1 &lt;= st2</li>
    </ul>
  </ul>
</section>
<section>
  <h2>struct: Comparing</h2>
  <ul>
    <li>We can compare members of structs</li>
    <pre><code class="hljs lang-c">
if(
  (st1.id == st2.id) &amp;&amp;
  (strcmp(st1.name, st2.name) == 0) &amp;&amp;
  (strcmp(st1.fam_name, st2.fam_name) == 0)
) {
  /* st1 == st2 */
}
    </code></pre>
    <li>We can define &lt;, &lt;=, &gt;, &gt;= for struct</li>
    <pre><code class="hljs lang-c">
if (
  (st1.id &gt; st2.id) &amp;&amp;
  (strcmp(st1.name, st2.name) == 0) &amp;&amp;
  (strcmp(st1.fam_name, st2.fam_name) == 0)
) {
  /* st1 &gt; st2 */
}
    </code></pre>
  </ul>
</section>
<section>
  <h2>struct: Arithmetic operations</h2>
  <ul>
    <li>No arithmetic operation (+, -, /, ...) is defined for structures</li>
    <li>We can define ours operations</li>
    <li>We have an example in the following slides</li>
  </ul>
</section>
<section>
  <div class="toc" data-selected="2"></div>
</section>
<section>
  <h2>Array of struct: Definition</h2>
  <ul>
    <li><span class="cyan-select">struct</span> is a type &rarr; We can define array of struct</li>
    <pre><code class="hljs lang-c">
struct std1{
  int id;
  int grad;
};
struct std1 std_arr[20];

typedef struct{
  int id;
  int grad;
} std2;
std2 std_arr[20];
    </code></pre>
  </ul>
</section>
<section>
  <h2>Upper Average Students 🤓</h2>
  <pre><code class="hljs lang-c">
#include &lt;stdio.h&gt;

int main(void){
  struct std {
    int id;
    int grade;
  };

  const int num = 25;

  double sum, average;
  int i;
  struct std std_arr[num];
  for (i = 0; i &lt; num; i++){
    printf("Enter ID and grade\n");
    scanf("%d", &amp;(std_arr[i].id));
    scanf("%d", &amp;(std_arr[i].grade));
  }

  sum = 0;
  for(i = 0; i &lt; num; i++)
    sum += std_arr[i].grade;

  average = sum / num;

  for (i = 0; i &lt; num; i++)
    if (std_arr[i].grade &gt;= average)
      printf("Student %d passed\n", std_arr[i].id);

  return 0;
}
  </code></pre>
</section>
<section>
  <h2>Find Student</h2>
  <pre><code class="hljs lang-c">
#include &lt;stdio.h&gt;

int main(void) {
  struct std{
    char name[20];
    int id;
    int grade;
  };

  const int num = 25;
  struct std std_arr[num];

  int sid, i;
  for (i = 0; i &lt; num; i++){
    printf("Enter Name, ID and grade\n");
    scanf("%s", std_arr[i].name);
    scanf("%d", &amp;(std_arr[i].id));
    scanf("%d", &amp;(std_arr[i].grade));
  }
￼￼￼￼
  printf("Enter Search ID: ");
  scanf("%d", &amp;sid);

  for (i = 0; i &lt; num; i++) {
    if (std_arr[i].id == sid) {
      printf("Found:\n");
      printf("Name = %s\n", std_arr[i].name);
      printf("ID = %d\n", std_arr[i].id);
      printf("Grade = %s\n", std_arr[i].grade);
    }
  }
  return 0;
}
  </code></pre>
</section>
<section>
  <div class="toc" data-selected="2"></div>
</section>
<section>
  <h2>Pointer to struct: Definition</h2>
  <ul>
    <li>A variable of struct type is a <span class="orange-select">variable</span></li>
    <li>It has <span class="green-select">address</span>, we can have <span class="cyan-select">pointer</span> to it</li>
    <pre><code class="hljs lang-c">
struct std{
  int id;
  int grade;
};
struct std st1;
struct std *ps;
ps = &st1;
    </code></pre>
  </ul>
</section>
<section>
  <h2>Pointer to struct: Usage (Version 1)</h2>
  <ul>
    <li>We can use *pointer method</li>
    <li><span class="orange-select">*ps</span> means the content of the address that <span class="orange-select">ps</span> refers to there &rarr; it is struct</li>
    <li><span class="cyan-select">(*ps).id</span> is the member of struct that <span class="orange-select">ps</span> refers to it</li>
    <li><span class="cyan-select">(*ps).grade</span> is the member of struct that <span class="orange-select">ps</span> refers to it</li>
  </ul>
</section>
<section>
  <h2>Pointer to struct: Usage (Version 2)</h2>
  <ul>
    <li>We can use <span class="orange-select">“-&gt;"</span> method</li>
    <pre><code class="hljs lang-c">
struct std {
  int id;
  int grade;
};
struct std st1, *ps;
ps = &amp;st1
// (*ps).id
int y = ps-&gt;id;
// (*ps).grade
int z = ps-&gt;grade;
    </code></pre>
  </ul>
</section>
<section>
  <div class="toc" data-selected="2"></div>
</section>
<section>
  <h2>struct &amp; Functions</h2>
  <ul>
    <li>struct is a type &rarr; It can be used</li>
    <ul>
      <li>In <span class="orange-select">input</span> parameter list of functions</li>
      <ul>
        <li>Call by <span class="green-select">value</span></li>
        <li>Call by <span class="green-select">reference</span></li>
      </ul>
      <li>In <span class="orange-select">return type</span> of functions</li>
    </ul>
    <pre><code class="hljs lang-c">
void f(struct std s1); // call by value
void g(struct std *s2); // call by reference
struct std h(void); // return type
    </code></pre>
  </ul>
</section>
<section>
  <h2>struct & Functions: Example</h2>
  <ul>
    <li>struct as call by value input parameter</li>
  </ul>
  <pre><code class="hljs lang-c">
void print_st_info(information st){
  printf("Name = %s\n", st.name);
  printf("Fam = %s\n", st.fam_name);
  printf("id = %d\n", st.id);
  printf("grade = %d\n", st.grade);
}
// ----- Calling the function ----
information st1;
print_st_info(st1);
  </code></pre>
</section>
<section>
  <h2>struct & Functions: Example</h2>
  <ul>
    <li>struct as call by reference input parameter</li>
  </ul>
  <pre><code class="hljs lang-c">
void read_st_info(information *pst) {
  scanf("%s", pst-&gt;name);
  scanf("%s", pst-&gt;fam_name);
  scanf("%d", &amp;(pst-&gt;id));
  scanf("%d", &amp;(pst-&gt;grade));
}
// ----- Calling the function ----
information st1;
read_st_info(&amp;st1);
  </code></pre>
</section>
<section>
  <section>
    <h2>struct & Functions in Action</h2>
  </section>
  <section>
    <pre><code class="hljs lang-c">
struct student {
  char first_name[200];
  char last_name[200];
  int id[200];
};
    </code></pre>
  </section>
  <section>
    <p>
      Sets ID field of student with given identification.
      As you may guess this function must recieve <span class="orange-select">a pointer</span> of student structure.
    </p>
    <pre><code class="hljs lang-c">
void student_set_id(struct student *std, int id) {
  std-&gt;id = id;
}
    </code></pre>
  </section>
  <section>
    <p>
      Sets first name field of student with given Name
      As you may guess this function must recieve <span class="orange-select">a pointer</span> of student structure.
      But why?
    </p>
    <pre><code class="hljs lang-c">
void student_set_id(struct student *std, const char *name) {
  strcpy(sed-&gt;first_name, name)
}
    </code></pre>
  </section>
  <section>
    <p>
      First name field of stduent is an array and as you may remember arrays name contains the address of array's
      first cell. So is the following code is correct? 🤔
    </p>
    <pre><code class="hljs lang-c">
void student_set_id_wrong(struct student *std, const char *name) {
  strcpy(sed.first_name, name)
}
    </code></pre>
    <p>
      <span class="red-select">No.</span> It doesn't change first name of given student structure.
    </p>
    <p>
      Because C copies all of the structures' members, <span class="green-select">even if they are arrays</span>,
      so <span class="orange-select">Calling by Value</span> makes a copy from each field of the structure
      that changing them doesn't change anything in the source.
    </p>
  </section>
  <section>
    <p>
      As a rule of thumb <span class="violet-select">always</span> use pointer of structures in your functions even you don't want to change them.
      In case of read-only functions use <span class="cyan-select">const</span> pointers to tell the users you don't
      want to change the given structure.
    </p>
    <pre><code class="hljs lang-c">
void student_print(const struct student *std) {
  printf("Name: %s %s\n", std-&gt;first_name, std-&gt;last_name);
  printf("ID: %d\n", std-&gt;id);
}
    </code></pre>
  </section>
</section>
<section>
  <h2>struct & Functions: Example</h2>
  <ul>
    <li>struct as output of function</li>
  </ul>
  <pre><code class="hljs lang-c">
information create_st_info(void) {
  information tmp;
  scanf("%s", tmp.name);
  scanf("%s", tmp.fam_name);
  scanf("%d", &amp;tmp.id);
  scanf("%d", &amp;tmp.grade);
  return tmp;
}
// ----- Calling the function ----
information st1;
st1 = create_st_info();
  </code></pre>
</section>
<section>
  <h2>Scope of struct definition</h2>
  <ul>
    <li>A struct can be used only</li>
    <ul>
      <li>In the defined scope</li>
      <li>After definition</li>
    </ul>
    <li>if sruct is defined in a function</li>
    <ul>
      <li>It can be used only in the function</li>
      <li>No other function knows about it</li>
    </ul>
    <li>If struct is defined as a global</li>
    <ul>
      <li>It can be used in all function after the definition</li>
    </ul>
  </ul>
</section>
<section>
  <h2>Scope of struct variables</h2>
  <ul>
    <li>The scope of struct <span class="orange-select">variables</span> are the same other variables</li>
    <li>If struct variable is global</li>
    <ul>
      <li>Initialized to zero and visible to the functions after its declaration</li>
    </ul>
    <li>If struct variable is automatic local</li>
    <ul>
      <li>There is not any initial value, destroyed when the block finishes</li>
    </ul>
    <li>If struct variable is static</li>
    <ul>
      <li>Kept in memory until program finishs</li>
    </ul>
  </ul>
</section>
<section>
  <div class="toc" data-selected="3"></div>
</section>
<section>
  <section>
    <h2>More Dynamic Data Structures</h2>
    <ul>
      <li>In Arrays</li>
      <ul>
        <li>We know the size of array when you <span class="green-select">develop code (coding time)</span></li>
        <li>We know the size of array when <span class="cyan-select">program runs</span></li>
      </ul>
      <li>What can we do, if we <span class="orange-select">don’t know data size</span> even in run time?</li>
      <ul>
        <li>We use dynamic memory allocation &amp; resize</li>
        <ul>
          <li>Resizing array has cost &amp; overhead</li>
        </ul>
      </ul>
    </ul>
  </section>
  <section>
    <ul>
      <li>What can we do, if we want to <span class="orange-select">add/remove</span> an element to/from middle of the array?</li>
      <ul>
        <li>We use dynamic memory allocation &amp; resize</li>
        <ul>
          <li>Resizing array has cost &amp; overhead</li>
        </ul>
        <li>Is there any other better approach?</li>
      </ul>
    </ul>
  </section>
</section>
<section>
  <h2>Dynamic Data Structures: Linked List</h2>
  <ul>
    <li><span class="orange-select">linked list</span> data structure can be used to implement the dynamic structures</li>
    <li>linked list: Nodes that linked together</li>
    <ul>
      <li><span class="green-select">info(s)</span>: Save the information</li>
      <li><span class="cyan-select">next</span>: Pointer to the next node</li>
      <li><span class="violet-select">previous</span>: Pointer to the previous node</li>
    </ul>
  </ul>
</section>
<section>
  <img alt="ll-1" src="img/ll-1.png">
  <img alt="ll-2" src="img/ll-2.png">
</section>
<section>
  <h2>linked list in C</h2>
  <ul>
    <li>linked list is implemented by <span class="orange-select">struct</span> and <span class="green-select">pointer to struct</span></li>
    <li>Struct has a member to save the info</li>
    <li>Struct has a pointer to point the next node</li>
    <pre><code class="hljs lang-c">
struct node{
  int info;
  struct node *next;
};
    </code></pre>
  </ul>
</section>
<section>
  <p>
    Please note that we <span class="red-select">cannot</span> have structures that <span class="green-select">contain themselves</span>:
  </p>
  <pre><code class="hljs lang-c">
struct node{
  int info;
  struct node next;
}; // compile error
  </code></pre>
  <p>
    <span class="orange-select">struct node</span> conatins a pointer to its type.
  </p>
</section>
<section>
  <h2>Create nodes</h2>
  <ul>
    <li>We need a function to create each node in list. The function does:</li>
    <ol>
      <li><span class="orange-select">Allocate</span> the memory</li>
      <li>Set the <span class="green-select">info</span> member</li>
      <li>Set the <span class="cyan-select">next</span> member</li>
      <li><span class="violet-select">Return</span> the pointer to new node</li>
    </ol>
  </ul>
</section>
<section>
  <h2>Create Node</h2>
  <pre><code class="hljs lang-c">
struct node{
  int info;
  struct node *next;
};


// Returning pointer!?!
// Is it safe?
// Why?
struct node* node_construct(int i) {
  struct node* nn = NULL;

  nn = malloc(sizeof(struct node));
  if (nn == NULL) {
   return NULL;
  }

  nn-&gt;info = i;
  nn-&gt;next = NULL;

  return nn;
}
  </code></pre>
</section>
<section>
  <p>
    We <span class="orange-select">can return</span> the address of <span class="green-select">heap-allocated</span> variables <span class="violet-select">from functions</span>.
    Heap variables are under our control, so they are <span class="cyan-select">continue existing</span> after the function completes.
  </p>
</section>
<section>
  <h2>Example: 3 Nodes List</h2>
  <pre><code class="hljs lang-c">
struct node* list = NULL;
list = node_construct(10);
list-&gt;next = node_construct(20);
list-&gt;next-&gt;next = node_construct(30);
  </code></pre>
</section>
<section>
  <h2>Operation on linked list</h2>
  <ul>
    <li>Print the list: <span class="orange-select">list_print</span></li>
    <li>Add new node to end of list: <span class="green-select">list_push_back</span></li>
    <li>Add new node to front of list: <span class="yellow-select">list_push_front</span></li>
    <li>Insert new node after some node: <span class="cyan-select">list_push_next</span></li>
    <li>Delete the first node in list: <span class="violet-select">list_pop_front</span></li>
    <li>Delete the end node in list: <span class="material-select">list_pop_back</span></li>
    <li>Delete a node from the middle of list: <span class="red-select">list_pop_next</span></li>
  </ul>
</section>
<section>
  <h2>print_list</h2>
  <pre><code class="hljs lang-c">
void list_print(struct node *list){
  struct node* current;

  for(current = list; current != NULL; current = current-&gt; next) {
    printf("%d\n", current-&gt;info)
  }
}
  </code></pre>
</section>
<section>
  <h2>list_push_back</h2>
  <pre><code class="hljs lang-c">
void list_push_back(struct node* list, struct node* nn){
  struct node* current;

  for(current = list; current-&gt; next != NULL; current = current-&gt; next);

  current-&gt;next = nn;
  nn-&gt;next = NULL;
}
  </code></pre>
</section>
<section>
  <section>
    <h2>list_pop_back (if more than 2 nodes)</h2>
    <p>
      X &rarr; Y &rarr; NULL
    </p>
    <hr>
    <ul>
      <li>Y = X-&gt;next</li>
    </ul>
    <hr>
    <ol>
      <li>free(Y)</li>
      <li>X-&gt;next = NULL</li>
    </ol>
  </section>
  <section>
    <pre><code class="hljs lang-c">
void list_pop_back(struct node* list) {
  struct node* current = list;
  while(current-&gt;next-&gt;next != NULL) {
    current = current-&gt;next;
  }

  free(current-&gt;next);
  current-&gt;next = NULL;
}
    </code></pre>
  </section>
</section>
<section>
  <section>
    <h2>list_push_front 🤔</h2>
    <pre><code class="hljs lang-c">
void list_push_front(struct node* list, struct node* nn) {
  nn-&gt;next = list;
  list = nn;
}
    </code></pre>
  </section>
  <section>
    <h2>list_push_front 😱</h2>
    <pre><code class="hljs lang-c">
void list_push_front(struct node** plist, struct node* nn) {
  nn-&gt;next = *plist;
  *plist = nn;
}
    </code></pre>
  </section>
</section>
<section>
  <section>
    <h2>list_pop_next</h2>
    <p>
      X &rarr; Y &rarr; Z
    </p>
    <hr>
    <ul>
      <li>Y = X-&gt;next</li>
      <li>Z = Y-&gt;next</li>
      <li>Z = X-&gt;next-&gt;next</li>
    </ul>
    <hr>
    <ol>
      <li>X-&gt;next = Z</li>
      <li>free(Y)</li>
    </ol>
  </section>
  <section>
    <pre><code class="hljs lang-c">
void list_pop_by_info(struct node* list, int v) {
  // find a node before the node that contains v
  struct node* current = list;
  for (current = list; current-&gt;next != NULL &amp;&amp; current-&gt;next-&gt;info != v; current = current-&gt;next);

  // there is no node that conaints v
  if (current-&gt;next == NULL) {
    return;
  }

  list_pop_next(current);
}
    </code></pre>
    <pre><code class="hljs lang-c">
void list_pop_next(struct node* adjacent_to_delete_node) {
  struct node* to_delete = adjacent_to_delete_node-&gt;next;
  adjacent_to_delete_node-&gt;next = to_delete-&gt;next;
  free(to_delete);
}
    </code></pre>
  </section>
</section>
<section>
  <h2>Common Bugs</h2>
  <ul>
    <li>The last <span class="orange-select">NULL</span> in Liked-list is very important</li>
    <ul>
      <li>Always keep it</li>
    </ul>
    <li>Operation of linked-list has many exceptions</li>
    <ul>
      <li>When list is empty</li>
      <li>When we want to add to the first of list</li>
      <li>...</li>
    </ul>
  </ul>
</section>
<section>
  <div class="toc" data-selected="4"></div>
</section>
<section>
  <h2>Introduction</h2>
  <ul>
    <li>Some data are naturally ordered</li>
    <ul>
      <li>Days of week</li>
      <li>Months of year</li>
    </ul>
    <li>We want to use the order, e.g.</li>
    <ul>
      <li>The number of visitors per day</li>
      <li>The salary per month</li>
    </ul>
    <li>We need an array</li>
    <ul>
      <li>visitors[<span class="green-select">0</span>] &rarr; The number of visitors in <span class="orange-select">Saturday</span></li>
      <li>visitors[<span class="green-select">1</span>] &rarr; The number of visitors in <span class="orange-select">Sunday</span></li>
    </ul>
  </ul>
</section>
<section>
  <h2>Introduction</h2>
  <ul>
    <li><span class="orange-select">Enumeration</span> is a mechanism to assign a name for each number</li>
    <li>We can use numbers instead of numbers</li>
    <ul>
      <li>More readable core</li>
    </ul>
    <li>E.g.</li>
    <pre><code class="hljs lang-c">
visitors[saturday], visitors[friday]
salary[april], salary[june]
    </code></pre>
  </ul>
</section>
<section>
  <h2>enum</h2>
  <ul>
    <li><span class="orange-select">enum</span> is used to define a set of names and their corresponding numbers</li>
    <pre><code class="hljs lang-c">
enum tag {name_1, name_2, …, name_N};
    </code></pre>
    <li><span class="green-select">tag</span> is the enumeration type</li>
    <ul>
      <li>We use it to define variables</li>
    </ul>
    <li><span class="cyan-select">name_1</span> is <span class="red-select">0</span></li>
    <li><span class="cyan-select">name_2</span> is <span class="red-select">1</span></li>
    <li><span class="cyan-select">name_{i}</span> is <span class="red-select">name_{i-1} + 1</span></li>
  </ul>
</section>
<section>
  <h2>enum</h2>
  <pre><code class="hljs lang-c">
enum week {sat, sun, mon, tue, wed, thu, fri};
  </code></pre>
  <p>
    sat = 0, sun = 1, mon = 2, …, fri = 6
  </p>
  <pre><code class="hljs lang-c">
enum year {feb, jan, mar, apr, may, jun, jul, aug, sep, oct, nov, des};
  </code></pre>
  <p>
    feb = 0, jan = 1, …, nov = 10, des = 11
  </p>
</section>
<section>
  <h2>enum</h2>
  <p>We can assign the numbers</p>
  <pre><code class="hljs lang-c">
enum week {sat = 1, sun, mon, tue, wed, thu, fri};
  </code></pre>
  <p>
    sat = 1, sun = 2, mon = 3, …, fri = 7
  </p>
  <pre><code class="hljs lang-c">
enum condition {False = 0, True, No = 0, Yes, Ghalat = 0, Dorost};
  </code></pre>
  <p>
    False = No = Ghalat = 0<br>
    True = Yes = Dorost = 1
  </p>
</section>
<section>
  <h2>enum</h2>
  <ul>
    <li>After definition of an enumeration</li>
    <li>We can use the tag to declare variables</li>
    <li>We can use the names to assign values to the variables</li>
  </ul>
  <pre><code class="hljs lang-c">
enum week { sat, sun, mon, tue, wed, thu, fri };
enum week day = sat;
for(day = sat; day &lt;= fri; day++)
  </code></pre>
</section>
<section>
  <h2>Example: Read the number of visitors</h2>
  <pre><code class="hljs lang-c">
enum week {sat, sun, mon, tue, wed, thu, fri};
int visitors[7];
enum week day;
for(day = sat; day &lt;= fri; day++)
  scanf("%d", &amp;visitors[day]);
  </code></pre>
</section>
<section>
  <h2>Caution</h2>
  <ul>
    <li>C compiler <span class="orange-select">does not</span> check the value is assigned to the enum variables</li>
    <pre><code class="hljs lang-c">
enum test1 {t1, t2, t3};
enum test2 {t4, t5, t6};
enum test1 t1v = t1;
enum test2 t2v = t4;
if(t1v == t2v) &rarr; true
t1v = t5;
t2v = 100;
    </code></pre>
  </ul>
</section>
<section>
  <div class="toc" data-selected="5"></div>
</section>
<section>
  <h2>Introduction</h2>
  <ul>
    <li>Like Structures, <span class="orange-select">union is a user defined data type</span>.</li>
    <li>In union, all members share the same memory location.</li>
  </ul>
</section>
<section>
  <h2>Introduction</h2>
  <img src="img/union.png">
</section>
<section>
  <pre><code class="hljs lang-c">
#include &lt;stdio.h&gt;

// Declaration of union is same as structures
union test {
    int x, y;
};

int main()
{
    // A union variable t
    union test t;

    t.x = 2; // t.y also gets value 2
    printf("After making x = 2:\n x = %d, y = %d\n\n",
           t.x, t.y);

    t.y = 10; // t.x is also updated to 10
    printf("After making y = 10:\n x = %d, y = %d\n\n",
           t.x, t.y);
    return 0;
}
  </code></pre>
  <pre><code class="hljs no-highlight">
After making x = 2:
 x = 2, y = 2

After making y = 10:
 x = 10, y = 10
  </code></pre>
</section>
<section>
  <pre><code class="hljs lang-c">
#include &lt;stdio.h&gt;

union test1 {
    int x;
    int y;
} Test1;

union test2 {
    int x;
    char y;
} Test2;

union test3 {
    int arr[10];
    char y;
} Test3;

int main()
{
    printf("sizeof(test1) = %lu, sizeof(test2) = %lu, "
           "sizeof(test3) = %lu",
           sizeof(Test1),
           sizeof(Test2), sizeof(Test3));
    return 0;
}
  </code></pre>
  <pre><code class="hljs no-highlight">
sizeof(test1) = 4, sizeof(test2) = 4, sizeof(test3) = 40
  </code></pre>
</section>
<section>
  <section>
    <h2>Legends</h2>
    <img height="300px" src="img/rob.jpg">
  </section>
  <section>
    <h6 class="fragment" data-fragment-index="1" style="color: #ff99ff;">Rob Pike</h6>
    <ul class="fragment" data-fragment-index="2">
      <li>Canadian programmer and author</li>
      <li>He is best known for his work on the Go programming language and at Bell Labs</li>
    </ul>
  </section>
</section>
